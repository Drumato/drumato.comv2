[{"categories":null,"content":"Maybe this post will be old cuz I’m developing peachcomb actively! This post introduces a Go parser-library that is being developed by me, called peachcomb . this library is aimed to reduce overhead with dynamically dispatching, and notify mismatching among parsers. To achieve them, I use Go Generics in peachcomb. Go Generics was released in Go 1.18. https://github.com/Drumato/peachcomb https://pkg.go.dev/github.com/Drumato/peachcomb This post won’t describe the detail of Go Generics. I’ll recommend you this tutorial to understand Go Generics briefly. https://go.dev/doc/tutorial/generics ","date":"2022-04-10","objectID":"/posts/peachcomb/:0:0","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#"},{"categories":null,"content":" 1 SampleTo use peachcomb, You should follow just 2-steps. Initialization and Calling it. Before describing in detail, I’ll show you the simplest sample to understand peachcomb’s usage. The below sample parses numbers that they’re separated by |. https://go.dev/play/p/qIbzx_IWxbr package main import ( \"github.com/Drumato/peachcomb/pkg/strparse\" \"github.com/Drumato/peachcomb/pkg/combinator\" ) func main() { element := strparse.Digit1() separator := strparse.Rune('|') p := combinator.Separated1(element, separator) i, o, err := p([]rune(\"123|456|789Drumato\")) fmt.Println(i) fmt.Printf(\"%s\\n\", o) fmt.Println(err) } $ go run main.go Drumato [123 456 789] \u003cnil\u003e i is the rest input that parser p consumed. o is the p ’s output. In this case, o forms like []string{\"123\", \"456\", \"789\"}. It’s just all of the peachcomb’s usage. ","date":"2022-04-10","objectID":"/posts/peachcomb/:1:0","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#sample"},{"categories":null,"content":" 2 InternalsI strongly refered Geal/nom, that is a parser library in Rust. Nom achieves to construct fast/generic parsers by constrainting trait bounds. ","date":"2022-04-10","objectID":"/posts/peachcomb/:2:0","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#internals"},{"categories":null,"content":" 2.1 Parser SignatureFirst of all, all parsers in peachcomb implements one signature, type Parser[E comparable, O parser.ParseOutput] . It’s defined such as below. type Parser[E comparable, O ParseOutput] func(input ParseInput[E]) (ParseInput[E], O, ParseError) type ParseInput[E comparable] []E type ParseOutput interface{} type ParseError interface { error } I think there are some merits caused by designing Parser signature. First, if users want to use a certain parser but peachcomb doesn’t suppport it, users can implement in their project, and pass them into generalized function in package combinator (e.g. Map()). Second, almost parsers can be implemented generically. We don’t need to prepare almost parsers by each input type. Last, users only needs to know the interface. Initialization and Calling. ","date":"2022-04-10","objectID":"/posts/peachcomb/:2:1","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#parser-signature"},{"categories":null,"content":" 2.2 Type ResolvingNow let’s see the type resolving among peachcomb’s parsers. The playable sample code is placed in Go Playground. https://go.dev/play/p/oiZCn732MOh package main import ( \"fmt\" \"github.com/Drumato/peachcomb/pkg/combinator\" \"github.com/Drumato/peachcomb/pkg/parser\" \"github.com/Drumato/peachcomb/pkg/strparse\" ) func main() { var element parser.Parser[rune, string] = strparse.Digit1() var separator parser.Parser[rune, rune] = strparse.Rune('|') var p parser.Parser[rune, []string] = combinator.Separated1(element, separator) var i []rune var o []string var err error i, o, err = p([]rune(\"123|456|789Drumato\")) fmt.Println(string(i)) fmt.Printf(\"%d\\n\", len(o)) fmt.Printf(\"%s %s %s\\n\", o[0], o[1], o[2]) fmt.Println(err) } element … A parser that receives []rune and returns string separator … A parser that receives []rune and returns rune p … A parser that receives []rune and returns []string the actual function signatures are like this. func Digit1() parser.Parser[rune, string] func Rune(expected rune) parser.Parser[rune, rune] func Separated1[ E comparable, EO parser.ParseOutput, SO parser.ParseOutput, ]( element parser.Parser[E, EO], separator parser.Parser[E, SO]) parser.Parser[E, []EO] Separated1()’s type parameters will be resolved to … E … rune EO … string SO … rune So finally we know p implements parser.Parser[rune, []string] at compiliation time. Next example shows us the peachcomb’s constraints. https://go.dev/play/p/J0pRsPk4_Pf package main import ( \"fmt\" \"github.com/Drumato/peachcomb/pkg/byteparse\" \"github.com/Drumato/peachcomb/pkg/combinator\" ) func main() { sub := byteparse.UInt8() p := combinator.Many1(sub) i, o, err := p([]rune(\"aaaabaa\")) fmt.Println(string(i)) fmt.Println(string(o)) fmt.Println(err) } parsers in the sample will be resolved to… sub … parser.Parser[byte, uint8] p … parser.Parser[byte, []uint8] As you know in Playground, this sample will be failed to compile. the actual error message is below. ./prog.go:13:23: cannot use []rune(\"aaaabaa\") (value of type []rune) as type parser.ParseInput[byte] in argument to p the above sample mismatched btw the actual input and the expected input. peachcomb can also detect inconsistencies among parsers. https://go.dev/play/p/bmPc3n7k5Jq package main import ( \"fmt\" \"github.com/Drumato/peachcomb/pkg/combinator\" \"github.com/Drumato/peachcomb/pkg/strparse\" ) func main() { sub := strparse.Digit1() p := combinator.Map(sub, func(v byte) (bool, error) { return v == 0, nil }) i, o, err := p([]byte(\"11112222abc\")) fmt.Println(string(i)) fmt.Println(o) fmt.Println(err) } the actual error message is below. ./prog.go:12:27: type func(v byte) (bool, error) of func(v byte) (bool, error) {…} does not match inferred type func(string) (O, error) for func(SO) (O, error) sub … parser.Parser[rune, string] p … parser.Parser[rune, bool] in brief, Map() forms like Map[E, SO, O](sub Parser[E, SO], fn SO -\u003e (O, error)) in this sample, p has E: rune, SO: string type parameters so p requires func (v string) -\u003e (O, error) as the 2nd argument， but the actual argument forms func(v byte) -\u003e (bool, error). ","date":"2022-04-10","objectID":"/posts/peachcomb/:2:2","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#type-resolving"},{"categories":null,"content":" 2.3 Custom Input TypesAlmost parsers can receive any custom input types to parse. If you want to know this mechanism in detail, please read the below example. https://github.com/Drumato/peachcomb/blob/v0.2.0/examples/custominput/main.go ","date":"2022-04-10","objectID":"/posts/peachcomb/:2:3","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#custom-input-types"},{"categories":null,"content":" 3 ConclusionToday I described you a Go parser library called peachcomb. If you’re interested in the project, pleace use this and send me feedbacks! ","date":"2022-04-10","objectID":"/posts/peachcomb/:3:0","series":null,"tags":["go","parser"],"title":"Go Parser Combinator with Go Generics","uri":"/posts/peachcomb/#conclusion"},{"categories":null,"content":"Now I’m playing with FRRouting and contributing with tiny PRs(my PRs have merged twice). Today I’ll introduce my recent PoC that achieves replacement SRv6 Manager with YANG backend. This PoC is related with FRR Northbound API so I’m interesting in it. This PoC is incomplete but it’s maybe helpful if you want to know about the FRR’s mechanism of Northbound API. You can see the PoC in here . ","date":"2022-01-04","objectID":"/posts/srv6-manager/:0:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#"},{"categories":null,"content":" 1 Prerequisites","date":"2022-01-04","objectID":"/posts/srv6-manager/:1:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#prerequisites"},{"categories":null,"content":" 1.1 FRR Zebra SRv6 ManagerIn FRR, Zebra daemon manages SRv6 resources intensively. And routing daemons(bgpd/isisd/etc) requests the resources to Zebra. Zebra provides the resource’s ownerships to them. It’s just a “Server - Client” model as you know. there is a component called SRv6 Manager in zebra. it’s responsible for managing SRv6 resources and the requests to them. I recommend you to read this topotest that demonstrates VPNv6 with BGP SRv6 for understanding SRv6 Manager. ","date":"2022-01-04","objectID":"/posts/srv6-manager/:1:1","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#frr-zebra-srv6-manager"},{"categories":null,"content":" 1.2 Northbound gRPCIn FRR you can use vtysh to configure dynamically. I think vtysh is the most popular way to interact FRR daemons. vtysh provides the experiences that are almost the same as Cisco’s interactive CLI. On the other hand, FRR provides another way called Northbound gRPC. It enables you to configure FRR daemons via gRPC communications. When FRR users want to interact with FRR daemons they only need to implement gRPC clients. You can see the detailed documentation in here and here . ","date":"2022-01-04","objectID":"/posts/srv6-manager/:1:2","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#northbound-grpc"},{"categories":null,"content":" 1.3 FRR YANG backendFRR achieves the Northbound gRPC with following method. modeling FRR configuration/operational-data by using YANG attaching Northbound API callbacks into the data model Each routing daemon doesn’t need to implement each API response handler. Requests from clients contain an XPath and corresponding callback is called automatically. There are some merits in centralizing configurations/operational-data into YANG definitions. First, network operators only need to refer YANG files if operators want to know about the data models and their structures. network operators are familiar with YANG. And YANG doesn’t depend on any programming languages and implementations. Second, We can refer network vendor’s YANG models in here. You only need to refer them if you want to unify the operations among vendor’s appliances and yours. ","date":"2022-01-04","objectID":"/posts/srv6-manager/:1:3","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#frr-yang-backend"},{"categories":null,"content":" 2 Main","date":"2022-01-04","objectID":"/posts/srv6-manager/:2:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#main"},{"categories":null,"content":" 2.1 Current StatusAs described above, there is a big motivation to replace FRR components with YANG backend. In fact FRR community set the roadmap to replace all daemons with YANG backend. Now the new management daemon called mgmtd is being proposed(I’ll describe it later). So I wanted to be familiar with FRR by implementing a YANG backend. Now SRv6 Manager doesn’t support Northbound API. But SRv6 Manager is responsible for important things in small code-base. I had read overall of SRv6 Manager roughly so I didn’t think it’s difficult to replace for me(in fact I faced on some issues later). So I decided to implement SRv6 Manager YANG backend. ","date":"2022-01-04","objectID":"/posts/srv6-manager/:2:1","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#current-status"},{"categories":null,"content":" 2.2 Goals replace SRv6 components in practical ways daemon side SRv6 Manager vtysh commands of course I keep SRv6 Manager correct I’m careful of srv6_locator topotest ","date":"2022-01-04","objectID":"/posts/srv6-manager/:2:2","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#goals"},{"categories":null,"content":" 3 Current ImplementationI considered the PoC of this task as three sub-tasks. define YANG files define and implement API callbacks that are corresponding to YANG data node change the logic of SRv6 vtysh commands ","date":"2022-01-04","objectID":"/posts/srv6-manager/:3:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#current-implementation"},{"categories":null,"content":" 3.1 Define YANG filesFirst of all I defined YANG files. The YANG files are the foundation of daemon/vtysh’s implementation. So I had to design them carefully. So I referred the YANG models of Cisco IOS-XR 7.5.1. I thought they’re already well-defined so they’re good references for me. There are some YANG files they’re related to SRv6, cfg and datatypes and oper. In FRR core logic I had to focus cfg and datatypes YANG. Cisco-IOS-XR-segment-routing-srv6-oper.yang Cisco-IOS-XR-segment-routing-srv6-datatypes.yang Cisco-IOS-XR-segment-routing-srv6-cfg.yang And I saw segment-routing-srv6-cfg:srv6 container-block just augments segment-routing-ms-cfg:sr block. segment-routing-ms-cfg is the entire model of Segment-Rouring. For now there was no segment-routing manager in zebra(described later) but I didn’t care about that. frr-srv6.yang … refers segment-routing-srv6-datatypes frr-zebra-sr.yang … refers segment-routing-ms-cfg that isn’t related to SRv6 Manager but it’s needed for consistency frr-zebra-srv6.yang … refers segment-routing-srv6-cfg ","date":"2022-01-04","objectID":"/posts/srv6-manager/:3:1","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#define-yang-files"},{"categories":null,"content":" 3.2 Northbound API CallbacksNext I implemented Northbound API callbacks they’re corresponding to each YANG node. For instance, router isis AREA_TAG command creates a new isisd instance in isisd. this command also instantiates a new YANG list-node entry and stores it into isisd’s YANG data tree. At this time the corresponding create callback is called automatically. I’ll describe some kinds of Northbound API callbacks. Callback Type Description create Configuration at creation of a list-node entry/type empty/leaf-list entry modify Configuration at modification of a leaf-node value destroy Configuration at deletion of a list-node entry/leaf-list entry/etc get_elem Operation at retrieving of a leaf/leaf-list entry/etc lookup_entry Operation at searching of a list-node entry with given key cli_show Operation prints a CLI command that is corresponding to a node cli_show_end Operation if a node(container/list-node/etc) opens CLI command block this callback prints the block’s beginning Next task is to implement these callbacks into each YANG model. I defined new struct frr_yang_module_info and passed it to the instantiation function of Zebra daemon. https://github.com/Drumato/frr/blob/a41251800b09b9b93726a18fb891127a3e10340b/zebra/zebra_srv6_nb.c#L31 /* stripped */ const struct frr_yang_module_info frr_zebra_srv6_info = { .name = \"frr-zebra-srv6\", .nodes = { { .xpath = \"/frr-zebra-sr:sr/frr-zebra-srv6:srv6\", .cbs = { .cli_show = cli_show_segment_routing_srv6, .cli_show_end = cli_show_segment_routing_srv6_end, }, .priority = NB_DFLT_PRIORITY - 1, }, { .xpath = \"/frr-zebra-sr:sr/frr-zebra-srv6:srv6/locators\", .cbs = { .cli_show = cli_show_srv6_locators, .cli_show_end = cli_show_srv6_locators_end, }, }, { .xpath = \"/frr-zebra-sr:sr/frr-zebra-srv6:srv6/locators/locators\", .cbs = { .cli_show = cli_show_srv6_locators_locators, .cli_show_end = cli_show_srv6_locators_locators_end, }, }, { .xpath = \"/frr-zebra-sr:sr/frr-zebra-srv6:srv6/locators/locators/locator\", .cbs = { .cli_show = cli_show_srv6_locator, .cli_show_end = cli_show_srv6_locator_end, .create = nb_lib_srv6_locator_create, .destroy = nb_lib_srv6_locator_destroy, }, }, /* stripped */ } }; I also defined struct frr_yang_module_info frr_zebra_sr_info same as frr_zebra_srv6_info. So finally I just needed to implement specified callbacks as above one by one. For instance I’ll show youw nb_lib_srv6_locator_create. that is a typical create callback. that is called when a new SRv6 locator is created. First of all, In FRR we should manage the both of YANG data tree and C data-structures. In this case nb_lib_srv6_locator_create calls zebra_srv6_locator_add() to update the master variable of SRv6 Manager. https://github.com/Drumato/frr/blob/a41251800b09b9b93726a18fb891127a3e10340b/zebra/zebra_srv6_nb_config.c#L29 // stripped /* * XPath: /frr-zebra-sr:sr/frr-zebra-srv6:srv6/locators/locators/locator */ int nb_lib_srv6_locator_create(struct nb_cb_create_args *args) { struct srv6_locator *loc; struct srv6_locator_chunk *chunk; const char *loc_name; if (args-\u003eevent != NB_EV_APPLY) return NB_OK; loc_name = yang_dnode_get_string(args-\u003ednode, \"./name\"); loc = zebra_srv6_locator_lookup(loc_name); if (!loc) { /* SRv6 manager pre-allocates one chunk for zclients */ loc = srv6_locator_alloc(loc_name); chunk = srv6_locator_chunk_alloc(); chunk-\u003eproto = NO_PROTO; listnode_add(loc-\u003echunks, chunk); } zebra_srv6_locator_add(loc); nb_running_set_entry(args-\u003ednode, loc); return NB_OK; } // stripped Next example is nb_lib_srv6_locator_prefix_modify. that is called when leaf prefix is modified. https://github.com/Drumato/frr/blob/a41251800b09b9b93726a18fb891127a3e10340b/zebra/zebra_srv6_nb_config.c#L124 // stripped /* * XPath: /frr-zebra-sr:sr/frr-zebra-srv6:srv6/locators/locators/locator/prefix/prefix */ int nb_lib_srv6_locator_prefix_modify(struct nb_cb_modify_args *args) { struct srv6_locator *locator; if (args-\u003eevent != NB_EV_APPLY) return NB_OK; locator = nb_running_get_entry(args-\u003ednode, NULL, true); ya","date":"2022-01-04","objectID":"/posts/srv6-manager/:3:2","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#northbound-api-callbacks"},{"categories":null,"content":" 3.3 SRv6 Manager CLINext I implemented vtysh commands side. Previously SRv6 Manager vtysh commands directly called daemon’s functions. So replace them with just calling Northbound API. First I’ll show srv6_locator_cmd that transitions to SRV6_LOC_NODE. https://github.com/Drumato/frr/blob/a41251800b09b9b93726a18fb891127a3e10340b/zebra/zebra_srv6_vty.c#L246 // stripped DEFPY_YANG_NOSH(srv6_locator, srv6_locator_cmd, \"locator LOC_NAME$name\", SRV6_LOCATOR_CMD_STR) { char xpath[XPATH_MAXLEN]; int rv; snprintf(xpath, sizeof(xpath), \"/frr-zebra-sr:sr\" \"/frr-zebra-srv6:srv6\" \"/locators/locators/locator[name='%s']\", name); nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL); rv = nb_cli_apply_changes(vty, xpath); if (rv == CMD_SUCCESS) VTY_PUSH_XPATH(SRV6_LOC_NODE, xpath); return rv; } // stripped I’ll also show an example of a cli_show callback. https://github.com/Drumato/frr/blob/a41251800b09b9b93726a18fb891127a3e10340b/zebra/zebra_srv6_vty.c#L405 // stripped void cli_show_srv6_locator(struct vty *vty, const struct lyd_node *dnode, bool show_defaults) { const char *loc_name = NULL; loc_name = yang_dnode_get_string(dnode, \"./name\"); vty_out(vty, \" locator %s\\n\", loc_name); } // stripped finally all configurations can be printed by cli_show callbacks. zebra_sr_config() function is called when show-running command is called. So I replaced it with cli_show callbacks. FRR provides nb_cli_show_dnode_cmds() , that recursively calls cli_show callback from a given dnode. https://github.com/Drumato/frr/blob/a41251800b09b9b93726a18fb891127a3e10340b/zebra/zebra_srv6_vty.c#L453 // stripped static int zebra_sr_config(struct vty *vty) { int write_count = 0; struct lyd_node *dnode; if (zebra_srv6_is_enable()) { dnode = yang_dnode_get(running_config-\u003ednode, \"/frr-zebra-sr:sr\" \"/frr-zebra-srv6:srv6\"); if (dnode) { nb_cli_show_dnode_cmds(vty, dnode, false); write_count++; } } return write_count; } // stripped ","date":"2022-01-04","objectID":"/posts/srv6-manager/:3:3","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#srv6-manager-cli"},{"categories":null,"content":" 4 Future WorksSo I’ve finished to pass srv6_locator topotest with YANG backend. But there are some issues yet. ","date":"2022-01-04","objectID":"/posts/srv6-manager/:4:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#future-works"},{"categories":null,"content":" 4.1 show yang operational-dataFor now this PoC only supports configurational callbacks. If user calls operational callbacks, it doesn’t work correctly. this indicates the show yang operational-data command will fail. To achieve it, I should know how to use get_keys/get_next/get_elem/lookup_entry callback. those API don’t have any comprehensive docs, so I’ll have to read the existing implementations. ","date":"2022-01-04","objectID":"/posts/srv6-manager/:4:1","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#show-yang-operational-data"},{"categories":null,"content":" 4.2 researching mgmtdNow a new YANG-based management daemon called mgmtd is proposed to FRR. this daemon will support following features. I think the daemon will improve our development/operational experiences. Frontend Interface for all API clients running/candidate/startup/etc databases Backend Interface for all FRR daemons each daemon only needs to interact with mgmtd and can handle any config/data this enables FRR daemons to unify implementations among them Candidate Config Commit Rollbacks/History ","date":"2022-01-04","objectID":"/posts/srv6-manager/:4:2","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#researching-mgmtd"},{"categories":null,"content":" 5 ConclusionToday I described my PoC and FRR current status. If you want to know more informations, please check the FRR community(GitHub and Slack)! ","date":"2022-01-04","objectID":"/posts/srv6-manager/:5:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#conclusion"},{"categories":null,"content":" 6 References http://docs.frrouting.org/en/latest/grpc.html http://docs.frrouting.org/projects/dev-guide/en/latest/grpc.html 【インターンレポート】FRRouting IS-IS SRv6 Extension 設計と実装に関して zebra: srv6 manager ","date":"2022-01-04","objectID":"/posts/srv6-manager/:6:0","series":null,"tags":["frr","srv6"],"title":"Replace FRR Zebra SRv6 Manager with YANG Backend","uri":"/posts/srv6-manager/#references"},{"categories":null,"content":"As you know Kubernetes provides many extensibilities to users. These extensibilities are explained in the official docs. Custom Controller CRD Admission Webhook Kubernetes Scheduler Plugin CNI Plugin In the same way, kubectl that is used by almost k8s operators, provides an extensibility to us. That is called kubectl plugin, we use the extensibility and utilize our operations. In this post I’ll describe you the overview of kubectl plugin. I’ll take up some subject about kubectl plugin, and finally I’ll introduce my project that is called kubectl-plugin-builder. ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:0:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#"},{"categories":null,"content":" 1 Background","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:1:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#background"},{"categories":null,"content":" 2 What is kubectl pluginkubectl plugin is just an executable. A executable can be a kubectl plugin when it is located in a directory that kubectl can recognize. the executable’s name must follow a naming convension(kubectl-*). The official docs introduces us to implement a kubectl plugin by using shell script. I think kubectl plugin has some merits but I think the most merit for k8s operators is uniformity. we unify k8s operations among kubectl and its plugins. we can check installed plugins using kubectl plugin list. There is a famous plugin called postfinance/kubectl-ns. kubernetes/sample-cli-plugin takes the concept. And awesome-kubectl-plugins introduces the plugin. This plugin manages the namespace context in a kubeconfig. I think kubectl plugin should follow one principle, “One Plugin Does One Thing” like this. ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:2:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#what-is-kubectl-plugin"},{"categories":null,"content":" 2.1 How to develop a new pluginI described in above, a kubectl plugin is just an executable. we can develop plugins whatever we use shell script/Python/Go as programming language. For now I focus one subject “My thought abount implementing kubectl plugins in best practices” I’ll strongly recommend you to use Go and its CLI application builder like spf13/cobra. There are 3 reasons. First, the biggest concern for kubernetes operators is Simplifying kubernetes operations. they don’t want to waste time about how to construct a new plugin. It means even if you develop a tiny plugin you should use scalable programming languages. Second, almost kubernetes ecosystems adopt Go. Core components(kube-apiserver/kube-scheduler/kubectl) are also. So Kubernetes engineers are close to Go. A plugin should be easy to understand when A newbie join to kubernetes operation team. This merit comes up with one idea that recommend us to use a mainstream programming language. Last, almost famous kubectl plugins are written in Go actually. Moreover they’re constructed with cobra. Development of kubectl plugin depends each case so there are few documents in the internet I think. but almost implementations of plugins are published. ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:2:1","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#how-to-develop-a-new-plugin"},{"categories":null,"content":" 3 Issues they are appeared by using GoYou need some boilerplates to implement a kubectl plugin by using Go. initialization client-go initialization cli-runtime for using common CLI flags(e.g. -n/--namespace) follows the practical ways Complete/Validate/Run model And we know some issues about development api client. how we develop it as testable/maintainable/simple? ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:3:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#issues-they-are-appeared-by-using-go"},{"categories":null,"content":" 4 kubectl-plugin-builderSo I referenced kubebuilder’s philosophy and achievements, and developed a builder that helps our plugin developments. It’s already published at GitHub. You can see the brief introduction here. There are some features. initializes a new plugin project constructs a cli application architecture from yaml declaratively flag command alias add a new command definition to the yaml controls the plugin’s output-format The implementation consists of few thousand LoC so it’s easy to understand. ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:4:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#kubectl-plugin-builder"},{"categories":null,"content":" 5 ConclusionToday I introduced some concerns about kubectl plugins and kubectl-plugin-builder. Please play with it and share your experiences with me! ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:5:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#conclusion"},{"categories":null,"content":" 6 References Extend kubectl with plugins ","date":"2021-12-06","objectID":"/posts/kubectl-plugin-builder/:6:0","series":null,"tags":["kubernetes","go","kubectl"],"title":"Kubectl Plugin Builder","uri":"/posts/kubectl-plugin-builder/#references"},{"categories":null,"content":" About","date":"0001-01-01","objectID":"/about/:0:0","series":[],"tags":[],"title":"","uri":"/about/#about"},{"categories":null,"content":" 1 Profile Name Yamato Sugawara Handle Drumato Interests Computer Science/Network/Infrastructure/Cloud/SRE/etc ","date":"0001-01-01","objectID":"/about/:1:0","series":[],"tags":[],"title":"","uri":"/about/#profile"},{"categories":null,"content":" 2 Contacts GitHub https://github.com/Drumato Twitter https://twitter.com/drumato/ Facebook https://www.facebook.com/drumato.yamato.sugawara LinkedIn https://www.linkedin.com/in/drumato/ ","date":"0001-01-01","objectID":"/about/:2:0","series":[],"tags":[],"title":"","uri":"/about/#contacts"},{"categories":null,"content":" 3 OSS Contributions FRRouting Zebra SRv6 Manager zebra: Add support for json output in srv6 locator detail command enable to transition to SEGMENT_ROUTING_NODE when pathd is disabled ","date":"0001-01-01","objectID":"/about/:3:0","series":[],"tags":[],"title":"","uri":"/about/#oss-contributions"},{"categories":null,"content":" 4 GitHub Repositories drumato.comv2 … My Blog with TypeScript + Next.js Depth … my 1st generation x86_64 toolchain Peachili … my toy compiler that doesn’t depends on libc asmpeach elfpeach elf-utilities ","date":"0001-01-01","objectID":"/about/:4:0","series":[],"tags":[],"title":"","uri":"/about/#github-repositories"},{"categories":null,"content":" 5 Slides Japanese as an SRE in SAKURA Internet Inc. 社内のKubernetes運用状況の改善活動について indivisual x64/aarch64コンパイラを含むミニツールチェーン+αの開発 - Cybozu Labs Youth 10th an incremental approach to implement an admission controller eBPF disassemblerを作る English Components of Kubernetes Cluster ","date":"0001-01-01","objectID":"/about/:5:0","series":[],"tags":[],"title":"","uri":"/about/#slides"},{"categories":null,"content":" 6 Books Japanese Zenn.dev [全部無料]最小限で理解しつつ作るELF parser入門 in Rust It introduces how to write an ELF parser by using nom(a popular parser combinator) I think this book is kind if you’re new to analyze/parse ELF Fanzines OtakuAssembly Vol.1(co-authored) ","date":"0001-01-01","objectID":"/about/:6:0","series":[],"tags":[],"title":"","uri":"/about/#books"},{"categories":null,"content":" 7 Events seccamp2019 Y-ⅡCコンパイラを自作してみよう! Trainee Report in Japanese SecHack365'19 Trainee Report in Japanese Report2 in Japanese Cybozu Labs Youth 10th Report in Japanese Online Summer Internship for Gophers 2020 Report in Japanese KLab Expert Camp#3 ","date":"0001-01-01","objectID":"/about/:7:0","series":[],"tags":[],"title":"","uri":"/about/#events"},{"categories":null,"content":" 8 Other Posts as an SRE in SAKURA Internet Inc. Japanese 社内のKubernetesクラスタ運用を効率化する基盤について as a part-timer of LINE Corporation Japanese 仮想ルータクラスタを自動でローリングアップデートする仕組みの検討と実装 BGP Graceful Restartに関わる各OSSルーティングプラットフォームの動向調査 ","date":"0001-01-01","objectID":"/about/:8:0","series":[],"tags":[],"title":"","uri":"/about/#other-posts"},{"categories":null,"content":" 9 CareerSee LinkedIn ","date":"0001-01-01","objectID":"/about/:9:0","series":[],"tags":[],"title":"","uri":"/about/#career"},{"categories":null,"content":" About drumato.com","date":"0001-01-01","objectID":"/thissite/:0:0","series":null,"tags":null,"title":"","uri":"/thissite/#about-drumatocom"},{"categories":null,"content":" 1 DisclaimerI’m not responsible for any of informations, knowleages, and the contents of these posts. ","date":"0001-01-01","objectID":"/thissite/:1:0","series":null,"tags":null,"title":"","uri":"/thissite/#disclaimer"},{"categories":null,"content":" 2 LicenseAll source codes in this site are distributed under CC BY 4.0. ","date":"0001-01-01","objectID":"/thissite/:2:0","series":null,"tags":null,"title":"","uri":"/thissite/#license"}]