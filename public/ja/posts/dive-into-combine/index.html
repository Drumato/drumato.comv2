<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">Rust製のパーサコンビネータcombine v4.4.0を覗き見する - drumato.com</title><meta name="Description" content=""><meta property="og:title" content="Rust製のパーサコンビネータcombine v4.4.0を覗き見する" />
<meta property="og:description" content="この記事は 言語実装 Advent Calendar 2020 の10日目です． 昨日は @kimiyuki さんの記事でした． 明日は @fukkun さんの記事です． Twitter等で rustcのコードリーディングを" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://drumato.com/ja/posts/dive-into-combine/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-10T00:00:00+00:00" /><meta property="og:site_name" content="drumato.com" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust製のパーサコンビネータcombine v4.4.0を覗き見する"/>
<meta name="twitter:description" content="この記事は 言語実装 Advent Calendar 2020 の10日目です． 昨日は @kimiyuki さんの記事でした． 明日は @fukkun さんの記事です． Twitter等で rustcのコードリーディングを"/>
<meta name="application-name" content="drumato.com">
<meta name="apple-mobile-web-app-title" content="drumato.com">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://drumato.com/ja/posts/dive-into-combine/" /><link rel="prev" href="http://drumato.com/ja/posts/dive-into-nom/" /><link rel="next" href="http://drumato.com/ja/posts/type-system1/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Rust製のパーサコンビネータcombine v4.4.0を覗き見する",
        "inLanguage": "ja",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/drumato.com\/ja\/posts\/dive-into-combine\/"
        },"genre": "posts","keywords": "parser-combinator, code-reading, combine, rust","wordcount":  4113 ,
        "url": "http:\/\/drumato.com\/ja\/posts\/dive-into-combine\/","datePublished": "2020-12-10T00:00:00+00:00","dateModified": "2020-12-10T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": "Drumato"},"author": {
                "@type": "Person",
                "name": "Drumato"
            },"description": ""
    }
    </script></head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark');}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/ja/" title="drumato.com"><span id="desktop-header-typeit" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/ja/about/"> About </a><a class="menu-item" href="/ja/posts/"> 記事一覧 </a><a class="menu-item" href="/ja/diaries/"> 日記一覧 </a><a class="menu-item" href="/ja/thissite/"> このサイトについて </a><span class="menu-item delimiter"></span><a href="#" onclick="return false;" class="menu-item language" title="Select Language">Japanese<i class="fas fa-chevron-right fa-fw"></i>
                        <select class="language-select" title="Select Language" id="language-select-desktop" onchange="location = this.value;"><option value="/ja/posts/dive-into-combine/" selected>Japanese</option></select>
                    </a><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/ja/" title="drumato.com"><span id="mobile-header-typeit" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/ja/about/" title="">About</a><a class="menu-item" href="/ja/posts/" title="">記事一覧</a><a class="menu-item" href="/ja/diaries/" title="">日記一覧</a><a class="menu-item" href="/ja/thissite/" title="">このサイトについて</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a><a href="#" onclick="return false;" class="menu-item" title="Select Language">Japanese<i class="fas fa-chevron-right fa-fw"></i>
                    <select class="language-select" title="Select Language" onchange="location = this.value;"><option value="/ja/posts/dive-into-combine/" selected>Japanese</option></select>
                </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">Contents</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#motivation">Motivation</a></li>
    <li><a href="#サンプルから読み始める">サンプルから読み始める</a>
      <ul>
        <li><a href="#parsercharletter"><code>parser::char::letter</code></a>
          <ul>
            <li><a href="#letter-で使われている各種トレイトや型"><code>letter()</code> で使われている各種トレイトや型</a></li>
            <li><a href="#letter-内部"><code>letter()</code> 内部</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#まとめ">まとめ</a></li>
    <li><a href="#余談-anyhttpsdocsrscombine440combinefnanyhtml-について">余談: <a href="https://docs.rs/combine/4.4.0/combine/fn.any.html"><code>any</code></a> について</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Rust製のパーサコンビネータcombine v4.4.0を覗き見する</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/ja/" title="Author" rel=" author" class="author">Drumato</a>
                </span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-12-10">2020-12-10</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2020-12-10">2020-12-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;4113 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;9 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#motivation">Motivation</a></li>
    <li><a href="#サンプルから読み始める">サンプルから読み始める</a>
      <ul>
        <li><a href="#parsercharletter"><code>parser::char::letter</code></a>
          <ul>
            <li><a href="#letter-で使われている各種トレイトや型"><code>letter()</code> で使われている各種トレイトや型</a></li>
            <li><a href="#letter-内部"><code>letter()</code> 内部</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#まとめ">まとめ</a></li>
    <li><a href="#余談-anyhttpsdocsrscombine440combinefnanyhtml-について">余談: <a href="https://docs.rs/combine/4.4.0/combine/fn.any.html"><code>any</code></a> について</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>この記事は <a href="https://qiita.com/advent-calendar/2020/lang_dev" target="_blank" rel="noopener noreferrer">言語実装 Advent Calendar 2020</a> の10日目です．<br>
昨日は <a href="https://qiita.com/kimiyuki" target="_blank" rel="noopener noreferrer">@kimiyuki</a> さんの記事でした．<br>
明日は <a href="https://qiita.com/fukkun" target="_blank" rel="noopener noreferrer">@fukkun</a> さんの記事です．</p>
<p>Twitter等で <strong>rustcのコードリーディングを助ける為の記事</strong> を書くみたいなこと言っていましたが，<br>
ある理由により実現できませんでした．</p>
<h2 id="motivation" class="headerLink">
    <a href="#motivation" class="header-mark"></a>1 Motivation</h2><p>つい先日，<a href="https://drumato.com/ja/posts/dive-into-nom-internals/" target="_blank" rel="noopener noreferrer">このような記事</a>を上げました．</p>
<p>nomという比較的よく使われるパーサコンビネータについて解析し，<br>
パーサコンビネータとRustに詳しくなろう，みたいな目的の記事です．<br>
思ったより多くの方にご覧頂けたようで，大変嬉しく思っております．</p>
<p>この記事の冒頭で言っていた，まさにそれです．<br>
combineも同様に理解することで，更にRustに詳しくなろうと考えています．</p>
<p>パーサコンビネータについての解説等は特にしないですし，<br>
｢nomと比較してxxな実装なんですね｣という切り口で解説したいと思っているので，<br>
是非nom解説の記事もご覧頂ければと思います．<br>
実際にnom解説を理解したあとこちらの記事に戻ってくると，<br>
あまり理解するのに時間はかからないんじゃないかなと思います．<br>
<del>nom解説の記事は2,3週間練って作ったものなので出来がいいのもあります</del></p>
<p>2つのプロジェクトの規模感を把握するために，<br>
clocを使って比較してみました．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ cloc nom/src/
</span></span><span class="line"><span class="cl">      32 text files.
</span></span><span class="line"><span class="cl">      32 unique files.
</span></span><span class="line"><span class="cl">       0 files ignored.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">github.com/AlDanial/cloc v 1.82  T=0.04 s (853.9 files/s, 581289.6 lines/s)
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Language                     files          blank        comment           code
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Rust                            32           1480           7348          12957
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">SUM:                            32           1480           7348          12957
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cloc combine/src/
</span></span><span class="line"><span class="cl">      23 text files.
</span></span><span class="line"><span class="cl">      23 unique files.
</span></span><span class="line"><span class="cl">       0 files ignored.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">github.com/AlDanial/cloc v 1.82  T=0.03 s (778.9 files/s, 551101.4 lines/s)
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Language                     files          blank        comment           code
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Rust                            23           1401           3594          11278
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">SUM:                            23           1401           3594          11278
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------
</span></span></code></pre></div><p>こうしてみると，そこまで大きな差はなさそうですね．</p>
<p>今回は <a href="https://github.com/Marwes/combine/tree/v4.4.0" target="_blank" rel="noopener noreferrer">v4.4.0</a> を対象に読み進めていきます．</p>
<h2 id="サンプルから読み始める" class="headerLink">
    <a href="#%e3%82%b5%e3%83%b3%e3%83%97%e3%83%ab%e3%81%8b%e3%82%89%e8%aa%ad%e3%81%bf%e5%a7%8b%e3%82%81%e3%82%8b" class="header-mark"></a>2 サンプルから読み始める</h2><p>READMEに書いてあるサンプルから読み始めて，<br>
サンプルで使われている各関数の実装を見てみることにしましょう．<br>
適宜コメントを加えているので，combineを使ったことない人も理解できると思います．<br>
<del>nomの記事もそうでしたし今回もそうですが，私はほぼ使ったことないまま記事を書いています</del></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">combine</span>::<span class="p">{</span><span class="n">many1</span><span class="p">,</span><span class="w"> </span><span class="n">Parser</span><span class="p">,</span><span class="w"> </span><span class="n">sep_by</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">combine</span>::<span class="n">parser</span>::<span class="kt">char</span>::<span class="p">{</span><span class="n">letter</span><span class="p">,</span><span class="w"> </span><span class="n">space</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// parser::char::letter はchar型の入力がstd::char::is_alphabeticを満たせばeatして返す
</span></span></span><span class="line"><span class="cl"><span class="c1">// many1 は引数に受け取ったパーサが一回以上適用できればパース成功とする
</span></span></span><span class="line"><span class="cl"><span class="c1">// ここで得られるwordという変数ももちろんパーサである(後述)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">many1</span><span class="p">(</span><span class="n">letter</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// sep_by は2つ目の引数に渡したパーサをseparatorとする構造をパースする
</span></span></span><span class="line"><span class="cl"><span class="c1">// 今回で言えばparser::char::space なので，スペース区切りの文字列をパースすると考えてくれれば良い
</span></span></span><span class="line"><span class="cl"><span class="c1">// 後述するが，各パーサはmap()メソッドを持つ．
</span></span></span><span class="line"><span class="cl"><span class="c1">// sep_by の返り値が Vec&lt;String&gt; であると注釈することで， 
</span></span></span><span class="line"><span class="cl"><span class="c1">// rustcは parser.parse() の成果物がStringだとわかる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sep_by</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">space</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">words</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;|</span><span class="w"> </span><span class="n">words</span><span class="p">.</span><span class="n">pop</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// parse() メソッドを呼び出すことで，実際にパースを実行する
</span></span></span><span class="line"><span class="cl"><span class="c1">// 今回は入力文字列としてとして &amp;&#39;static strを渡している
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;Pick up that word!&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// パース成功時，(パーサの成果物， eatされた文字列)というタプルが返る
</span></span></span><span class="line"><span class="cl"><span class="c1">// タプルの順番がnomと真逆なので注意
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">((</span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;word&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()),</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">)));</span><span class="w">
</span></span></span></code></pre></div><p>私の解説では(個人的好みにつき)一切触れませんでしたが，<br>
一般的には <strong>&ldquo;マクロのnomと関数のcombine&rdquo;</strong> みたいな比較をされることが多いです．<br>
但し前回の記事で散々説明したようにnomには関数APIも存在するので，<br>
この比較は現在あまり意味がありません．</p>
<h3 id="parsercharletter" class="headerLink">
    <a href="#parsercharletter" class="header-mark"></a>2.1 <code>parser::char::letter</code></h3><p>非常にシンプルな機能を提供する関数だとわかったので，<br>
この関数を見ていくことでcombineの設計を覗き見ることにします．<br>
実際のコードを見てみると，<br>
提供する機能と同じく非常にシンプルな実装になっていることがわかります．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// Parses an alphabet letter according to [`std::char::is_alphabetic`].
</span></span></span><span class="line"><span class="cl"><span class="sd">///
</span></span></span><span class="line"><span class="cl"><span class="sd">/// [`std::char::is_alphabetic`]: https://doc.rust-lang.org/std/primitive.char.html#method.is_alphabetic
</span></span></span><span class="line"><span class="cl"><span class="sd">///
</span></span></span><span class="line"><span class="cl"><span class="sd">/// ```
</span></span></span><span class="line"><span class="cl"><span class="sd">/// use combine::Parser;
</span></span></span><span class="line"><span class="cl"><span class="sd">/// use combine::parser::char::letter;
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert_eq!(letter().parse(&#34;a&#34;), Ok((&#39;a&#39;, &#34;&#34;)));
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert_eq!(letter().parse(&#34;A&#34;), Ok((&#39;A&#39;, &#34;&#34;)));
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert!(letter().parse(&#34;9&#34;).is_err());
</span></span></span><span class="line"><span class="cl"><span class="sd">/// ```
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">letter</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">PartialState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="o">&lt;</span><span class="n">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>::<span class="n">Error</span>: <span class="nc">ParseError</span><span class="o">&lt;</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Range</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Position</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span>: <span class="kt">char</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_alphabetic</span><span class="p">()).</span><span class="n">expected</span><span class="p">(</span><span class="s">&#34;letter&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>where</code> 句で設けられているトレイト境界ですが，nomの時と似たような感じになっていますね．<br>
この関数を <strong>ボトムアップ</strong> 的に理解することにしましょう．<br>
ボトムアップ式理解の欠点として，<br>
<strong>ずっと不安感を覚えながら読みすすめる必要がある</strong> というのがあるので，<br>
ここで簡潔に <code>letter()</code> の理解の方針を示します．</p>
<ul>
<li>まず <code>letter()</code> の定義で用いられているトレイトや型を簡潔に説明します
<ul>
<li>これによって，<code>letter()</code> が生成するパーサはどんな入力を受け取れて何を返すかがわかります</li>
</ul>
</li>
<li>次に関数内部を理解します
<ul>
<li>今回で言えば <code>satisfy()</code> が何をするのか，ということです</li>
</ul>
</li>
</ul>
<h4 id="letter-で使われている各種トレイトや型" class="headerLink">
    <a href="#letter-%e3%81%a7%e4%bd%bf%e3%82%8f%e3%82%8c%e3%81%a6%e3%81%84%e3%82%8b%e5%90%84%e7%a8%ae%e3%83%88%e3%83%ac%e3%82%a4%e3%83%88%e3%82%84%e5%9e%8b" class="header-mark"></a>2.1.1 <code>letter()</code> で使われている各種トレイトや型</h4><p>まず気になるのは返り値の型とされているimpl Objectです．<br>
これは<code>Parser</code>トレイトを実装する型を返すようです．<br>
nomでは <code>Fn(Input) -&gt; IResult&lt;Input, Output, Error&gt;</code> のように <code>Fn</code> トレイトがそのまま使われていましたが，<br>
combineでは少し異なる実装がされているようですね．<br>
<a href="https://docs.rs/combine/4.4.0/combine/trait.Parser.html" target="_blank" rel="noopener noreferrer">ドキュメント</a>を見てみましょう．</p>
<p>いくつかのメソッドがありますが，<br>
とりあえずは <code>fn parse(&amp;mut self, input: Input) -&gt; Result&lt;(Self::Output, Input), &lt;Input as StreamOnce&gt;::Error&gt;</code> だけ理解できていれば大丈夫です．<br>
そしてこれ，まさしく先程言っていたように，<br>
nomにおける <code>Fn(Input) -&gt; IResult&lt;Input, Output, Error&gt;</code> に似たものを感じます．</p>
<p>ドキュメントの内容と合わせるとかなり多くの型が出てきたので，整理したいと思います．</p>
<ul>
<li><code>Parser&lt;Input: Stream&gt;</code> は各関数が返す&quot;パーサが実装するトレイト&quot;
<ul>
<li>associated typeとして <code>Output</code> を持ち，これはパーサの成果物の型を指定する
<ul>
<li>今回でいえば <code>Output = char</code></li>
</ul>
</li>
<li><code>fn parse()</code> はパース実行のエントリポイント</li>
</ul>
</li>
<li><a href="https://docs.rs/combine/4.4.0/combine/trait.Stream.html" target="_blank" rel="noopener noreferrer"><code>Stream</code></a> は3つのトレイトの集合的存在
<ul>
<li><a href="https://docs.rs/combine/4.4.0/combine/trait.StreamOnce.html" target="_blank" rel="noopener noreferrer"><code>StreamOnce</code></a></li>
<li><a href="https://docs.rs/combine/4.4.0/combine/trait.Positioned.html" target="_blank" rel="noopener noreferrer"><code>Positioned</code></a></li>
<li><a href="https://docs.rs/combine/4.4.0/combine/stream/trait.ResetStream.html" target="_blank" rel="noopener noreferrer"><code>ResetStream</code></a></li>
</ul>
</li>
<li><a href="https://docs.rs/combine/4.4.0/combine/trait.ParseError.html" target="_blank" rel="noopener noreferrer">ParseError</a> はそのままパーサエラーの定義</li>
</ul>
<p>と，ここまで言われても&quot;ナンノコッチャ&quot;ってなってると思います，<br>
nomと同様，トレイトとジェネリクスを最大限活用してゼロコスト抽象化を実現している点は変わらないようです．</p>
<p>今回も同じく <code>&amp;str</code> に限定して考えます．<br>
まずは以下のコードを見てみましょう．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StreamOnce</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">char</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PointerOffset</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StringStreamError</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">uncons</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">StreamErrorFor</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">chars</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">chars</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chars</span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">StringStreamError</span>::<span class="n">Eoi</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Positioned</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">T</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">PointerOffset</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Positioned</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">PointerOffset</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">().</span><span class="n">position</span><span class="p">().</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[doc(hidden)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[macro_export]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">clone_resetable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">((</span><span class="w"> </span><span class="cp">$($params</span>: <span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="cp">$ty</span>: <span class="nc">ty</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$($params</span><span class="p">)</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">ResetStream</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$ty</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nc">StreamOnce</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">type</span> <span class="nc">Checkpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">fn</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">fn</span> <span class="nf">reset</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">checkpoint</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">checkpoint</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">clone_resetable</span><span class="o">!</span><span class="w"> </span><span class="p">{(</span><span class="o">&#39;</span><span class="na">a</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>やっぱりこうして一つのトレイト実装を見てみると非常にわかりやすいですね．<br>
<code>StreamOnce::uncons()</code> を見ると，<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.pop_front" target="_blank" rel="noopener noreferrer"><code>std::collections::VecDeque::pop_front()</code></a> のような動作に見えます．<br>
<code>Positioned::position()</code> は， <code>impl&lt;'a, T&gt; Positioned for &amp;'a [T]</code> によってスライスに対する定義が行われ，<br>
それを流用する形で <code>&lt;&amp;[u8]&gt;::position()</code> を呼び出しています．<br>
<code>ResetPosition</code> に関してはマクロによって実装されていますが，<br>
<code>impl&lt;'a&gt; ResetStream for &amp;'a str</code> のような展開がされることがわかれば，あとは普通のimplブロックです．<br>
私は普段Rustを書くとき一切マクロを使わないですが，<br>
Rustのマクロは比較的分かりやすい上に <a href="https://doc.rust-lang.org/reference/macros-by-example.html" target="_blank" rel="noopener noreferrer">ドキュメント</a> もあるので，<br>
あまり読むのに困ったことはありません．</p>
<p>3つのトレイトの実装について大まかにわかったところで，<br>
<code>Stream</code> トレイトも見てみます．<br>
とはいっても，3つのトレイトを頑張って理解した私達にとって難しいことは特にありません．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Stream</span>: <span class="nc">StreamOnce</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ResetStream</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Positioned</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Stream</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Input</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">StreamOnce</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Positioned</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ResetStream</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>::<span class="n">Error</span>: <span class="nc">ParseError</span><span class="o">&lt;</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Range</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Position</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>&amp;str</code> に限定して考えたとき，<br>
<code>Input::Token = char</code>, <code>Input::Range = &amp;str</code>, <code>Input::Position = PointerOffset&lt;str&gt;</code> であるとわかっています．<br>
また先程説明を省略しましたが，<br>
<code>Input::Error = StringStreamError</code> であり， <code>impl ParseError for StringStreamError</code> はデフォルトのものが存在します．</p>
<p>ここまでの説明を経て，やっと <code>letter()</code> が生成するパーサに <code>&amp;str</code> を渡せることがわかったのです．</p>
<h4 id="letter-内部" class="headerLink">
    <a href="#letter-%e5%86%85%e9%83%a8" class="header-mark"></a>2.1.2 <code>letter()</code> 内部</h4><p>ここでもう一度 <code>parser::char::letter()</code> の定義を持ってきましょう．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">letter</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">PartialState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="o">&lt;</span><span class="n">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>::<span class="n">Error</span>: <span class="nc">ParseError</span><span class="o">&lt;</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Range</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Position</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span>: <span class="kt">char</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_alphabetic</span><span class="p">()).</span><span class="n">expected</span><span class="p">(</span><span class="s">&#34;letter&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>もう特に説明しなくても関数シグネチャについては理解できそうですね．</p>
<p><code>parser::token::satisfy()</code> についても <a href="https://drumato.hatenablog.com/entry/dive-into-nom#nomcharactercompletesatisfy" target="_blank" rel="noopener noreferrer">前の貯金</a> があるので予想はつきますが，<br>
この記事は &ldquo;nomとcombineの違いを知る&rdquo; のが趣旨なので，素直に読むとしましょう．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Satisfy</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">satisfy</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Satisfy</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Satisfy</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">predicate</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_marker</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>parser::token::satisfy()</code> は構造体 <code>parser::token::Satisfy&lt;Input, P&gt;</code> を返すようですね．<br>
この段階で，この構造体が <code>Parser</code> トレイトを実装しているんだろうなあ，という予想が付きます．</p>
<p><code>PhantomData&lt;T&gt;</code> ってなんだろう，と疑問に思った方もいるかもしれません．<br>
これについては <a href="https://qnighy.hatenablog.com/entry/2018/01/14/220000" target="_blank" rel="noopener noreferrer">qnighy</a> さんの記事が非常に詳しいです．</p>
<p><code>impl&lt;Input, P&gt; Parser&lt;Input&gt; for Satisfy&lt;Input, P&gt;</code> を見てみましょう．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Satisfy</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Token</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">PartialState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse_lazy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Input</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ParseResult</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">satisfy_impl</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">predicate</span><span class="p">)(</span><span class="n">c</span><span class="p">.</span><span class="n">clone</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">None</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">satisfy_impl</span><span class="o">&lt;</span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Input</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ParseResult</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">position</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">uncons</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">PeekOk</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CommitOk</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">predicate</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">CommitOk</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">PeekErr</span><span class="p">(</span><span class="n">Input</span>::<span class="n">Error</span>::<span class="n">empty</span><span class="p">(</span><span class="n">position</span><span class="p">).</span><span class="n">into</span><span class="p">()),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">PeekErr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">PeekErr</span><span class="p">(</span><span class="n">err</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CommitErr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">CommitErr</span><span class="p">(</span><span class="n">err</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>fn stream::uncons()</code> は <code>method Stream::uncons()</code> のラッパーです．<br>
返り値は <a href="https://docs.rs/combine/4.4.0/combine/enum.ParseResult.html" target="_blank" rel="noopener noreferrer"><code>ParseResult</code></a> というenumです．<br>
これも <code>&amp;str</code> に限定して考えてしまいましょう．<br>
<code>&amp;str</code> に対し <code>Stream::uncons()</code> を呼び出すと <code>std::collections::VecDeque::pop_first()</code> のように振る舞うとお話しました．<br>
この切り出された文字に対し <code>predicate</code> を適用したとき，<br>
その結果が <code>Option::Some</code> であればパース成功としその結果を保存します．<br>
そうでなければパースは失敗したとして <code>PeekErr</code> を返します．</p>
<hr>
<h2 id="まとめ" class="headerLink">
    <a href="#%e3%81%be%e3%81%a8%e3%82%81" class="header-mark"></a>3 まとめ</h2><ul>
<li>combineの提供する関数は <code>Parser</code> トレイトを実装する構造体を返す
<ul>
<li>返す構造体はAPI関数によって異なるが， <code>Parser</code> トレイトを実装するという点で共通している</li>
<li><code>Parser</code> トレイトは <code>Stream</code> トレイトを実装する入力を受け付ける</li>
<li>返り値は <code>Result&lt;(Self::Output, Input), &lt;Input as StreamOnce&gt;::Error&gt;</code> である</li>
</ul>
</li>
</ul>
<p>ここまでの道のりで分かる通り，<br>
nomと同じく&quot;汎用性の高いパーサコンビネータライブラリ&quot; を実現するための設計がされていることがわかります．<br>
Rustの型システムを最大限に活用するコードは見ていて楽しいですし，学びもありますね．</p>
<p>急ピッチで作成したので少しごちゃっとした，自分用メモみたいな記事になってしまいました．<br>
本当は <strong>Dockerfileの静的解析ツール</strong> みたいなやつを作って発表しようかなーなんて構想もありましたが，後の祭り．<br>
来年も絶対に参加するつもりなので，その時はちゃんと既存記事がないかどうかチェックしてから書くことにします．</p>
<h2 id="余談-anyhttpsdocsrscombine440combinefnanyhtml-について" class="headerLink">
    <a href="#%e4%bd%99%e8%ab%87-anyhttpsdocsrscombine440combinefnanyhtml-%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6" class="header-mark"></a>4 余談: <a href="https://docs.rs/combine/4.4.0/combine/fn.any.html" target="_blank" rel="noopener noreferrer"><code>any</code></a> について</h2><p>最もシンプルなパーサはこれだったんじゃないかと，今になって思い始めました．<br>
とにかくeatできればなんでもいい，なパーサを作ってくれます．</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">any</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Any</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Any</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Any</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="n">Input</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Input</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Any</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Input</span>: <span class="nc">Stream</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Token</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">PartialState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">parse_lazy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Input</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ParseResult</span><span class="o">&lt;</span><span class="n">Input</span>::<span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Input</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">uncons</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>fn stream::uncons()</code> に渡しているだけなのがわかります．<br>
要は先頭アイテムが切り取れればそれでいい，な実装です．<br>
わかりやすい．</p>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2020-12-10</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="#" onclick="return false;" title="Share on Twitter" data-sharer="twitter" data-url="http://drumato.com/ja/posts/dive-into-combine/" data-title="Rust製のパーサコンビネータcombine v4.4.0を覗き見する" data-hashtags="parser-combinator,code-reading,combine,rust"><i class="fab fa-twitter fa-fw"></i></a><a href="#" onclick="return false;" title="Share on Facebook" data-sharer="facebook" data-url="http://drumato.com/ja/posts/dive-into-combine/" data-hashtag="parser-combinator"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" onclick="return false;" title="Share on Hacker News" data-sharer="hackernews" data-url="http://drumato.com/ja/posts/dive-into-combine/" data-title="Rust製のパーサコンビネータcombine v4.4.0を覗き見する"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" onclick="return false;" title="Share on Reddit" data-sharer="reddit" data-url="http://drumato.com/ja/posts/dive-into-combine/"><i class="fab fa-reddit fa-fw"></i></a><a href="#" onclick="return false;" title="Share on Line" data-sharer="line" data-url="http://drumato.com/ja/posts/dive-into-combine/" data-title="Rust製のパーサコンビネータcombine v4.4.0を覗き見する"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="#" onclick="return false;" title="Share on Pocket" data-sharer="pocket" data-url="http://drumato.com/ja/posts/dive-into-combine/"><i class="fab fa-get-pocket fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/ja/tags/parser-combinator/">parser-combinator</a>,&nbsp;<a href="/ja/tags/code-reading/">code-reading</a>,&nbsp;<a href="/ja/tags/combine/">combine</a>,&nbsp;<a href="/ja/tags/rust/">rust</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/ja/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/ja/posts/dive-into-nom/" class="prev" rel="prev" title="Rust製のパーサコンビネータnom v6.0.0を解剖する"><i class="fas fa-angle-left fa-fw"></i>Rust製のパーサコンビネータnom v6.0.0を解剖する</a>
            <a href="/ja/posts/type-system1/" class="next" rel="next" title="Rustでつくる単相型システムもどき">Rustでつくる単相型システムもどき<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.108.0">Hugo</a>&nbsp;|&nbsp;Theme - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/ja/" target="_blank" rel="noopener noreferrer">Drumato</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="Back to Top">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/fuse/fuse.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>

<div class="pjax-assets"><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{},"data":{"desktop-header-typeit":"drumato.com","mobile-header-typeit":"drumato.com"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/ja/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"No results found","snippetLength":30,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"sharerjs":true,"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},"duration":null,"speed":null}};</script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript></div>
</body>

</html>